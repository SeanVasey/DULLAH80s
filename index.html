<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>DULLAH80s v3.0 | Retro Disco Studio</title>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#050505">

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                        mono: ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        charcoal: { 950: '#050505', 900: '#121214', 800: '#1c1c1f', 700: '#27272a' },
                        turquoise: { 400: '#2dd4bf', 500: '#14b8a6' },
                        slateBlue: { 400: '#818cf8', 500: '#6366f1', 600: '#4f46e5' },
                        deepPurple: { 500: '#9333ea', 600: '#7e22ce' }
                    },
                    animation: {
                        'glow-cycle': 'glowCycle 3s infinite alternate',
                    },
                    keyframes: {
                        glowCycle: {
                            '0%': { backgroundColor: 'rgba(147, 51, 234, 0.6)', transform: 'scale(1)' }, // Purple
                            '50%': { backgroundColor: 'rgba(45, 212, 191, 0.6)', transform: 'scale(1.1)' }, // Cyan
                            '100%': { backgroundColor: 'rgba(99, 102, 241, 0.6)', transform: 'scale(1)' }, // Blue
                        }
                    }
                }
            }
        }
    </script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body {
            overscroll-behavior-y: none; touch-action: none;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Inter', sans-serif;
            background-color: #050505; color: #e5e5e5; overflow: hidden;
            user-select: none; -webkit-user-select: none;
        }
        .pt-safe-top { padding-top: env(safe-area-inset-top); }
        .pb-safe-bottom { padding-bottom: env(safe-area-inset-bottom); }
        .hide-scroll::-webkit-scrollbar { display: none; }
        .hide-scroll { -ms-overflow-style: none; scrollbar-width: none; }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%;
            background: #2dd4bf; border: 2px solid #121214; cursor: pointer; margin-top: -6px;
            box-shadow: 0 0 10px rgba(45, 212, 191, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #27272a; border-radius: 2px; }
        
        /* Clear Milky Glass */
        .liquid-glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(30px) saturate(150%);
            -webkit-backdrop-filter: blur(30px) saturate(150%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
        }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.98); } to { opacity: 1; transform: scale(1); } }
        .animate-in { animation: fadeIn 0.2s ease-out forwards; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, memo } = React;

        // --- AUDIO UTILS ---
        const generateNoiseBuffer = (ctx) => {
            const bSize = ctx.sampleRate * 2.0;
            const buffer = ctx.createBuffer(1, bSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bSize; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        };

        const generateImpulseResponse = (ctx, duration, decay) => {
            const length = ctx.sampleRate * duration;
            const impulse = ctx.createBuffer(2, length, ctx.sampleRate);
            const l = impulse.getChannelData(0);
            const r = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const n = i / length;
                const alpha = Math.pow(1 - n, decay); 
                l[i] = (Math.random() * 2 - 1) * alpha;
                r[i] = (Math.random() * 2 - 1) * alpha;
            }
            return impulse;
        };

        const generateDistortionCurve = (amount) => {
            const k = amount;
            const n = 44100;
            const curve = new Float32Array(n);
            for (let i = 0; i < n; ++i) {
                let x = i * 2 / n - 1;
                curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
            }
            return curve;
        };

        // --- ICONS ---
        const Icon = ({ name, size = 16, className = "" }) => {
            const c = { width: size, height: size, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", className };
            const icons = {
                Settings: <svg {...c}><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.1a2 2 0 0 1-1-1.72v-.51a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>,
                Play: <svg {...c}><polygon points="5 3 19 12 5 21 5 3"/></svg>,
                Square: <svg {...c}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/></svg>,
                Copy: <svg {...c}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>,
                Paste: <svg {...c}><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/><rect x="8" y="2" width="8" height="4" rx="1" ry="1"/></svg>,
                Trash2: <svg {...c}><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>,
                ChevronUp: <svg {...c}><path d="m18 15-6-6-6 6"/></svg>,
                ChevronDown: <svg {...c}><path d="m6 9 6 6 6-6"/></svg>,
                Repeat: <svg {...c}><polyline points="17 1 21 5 17 9"/><path d="M3 11V9a4 4 0 0 1 4-4h14"/><polyline points="7 23 3 19 7 15"/><path d="M21 13v2a4 4 0 0 1-4 4H3"/></svg>,
                Check: <svg {...c}><polyline points="20 6 9 17 4 12"/></svg>,
                Help: <svg {...c}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" x2="12.01" y1="17" y2="17"/></svg>,
                Undo: <svg {...c}><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>,
                Redo: <svg {...c}><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>,
                X: <svg {...c}><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
                Pencil: <svg {...c}><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>
            };
            return icons[name] || null;
        };

        const PAD_NAMES = ["KICK HVY", "KICK POP", "SNARE 1", "SNARE 2", "CLAP", "RIM", "CHAT", "OHAT", "TOM HI", "TOM LO", "PERC 1", "COWBELL", "CRASH", "LASER", "SHAKER", "VOX"];
        const PATTERN_KEYS = ['A', 'B', 'C', 'D'];

        const GridRow = memo(({ trackIdx, name, trackData, currentStep }) => {
            return (
                <div className="flex h-10 border-b border-charcoal-800/50 transition-colors">
                    <div className="w-20 shrink-0 bg-charcoal-900 border-r border-charcoal-800 flex items-center px-2 z-10 shadow-[2px_0_5px_rgba(0,0,0,0.2)]">
                        <span className="text-[9px] font-bold text-slate-400 truncate select-none">{name}</span>
                    </div>
                    <div className="flex-1 flex">
                        {trackData.map((val, stepIdx) => (
                            <div 
                                key={stepIdx}
                                data-track={trackIdx}
                                data-step={stepIdx}
                                className={`grid-cell flex-1 relative border-r border-charcoal-800/30 cursor-pointer ${stepIdx % 4 === 0 ? 'bg-white/5' : ''}`}
                            >
                                <div className={`
                                    absolute inset-[1px] rounded-[2px] transition-all duration-100 pointer-events-none
                                    ${val === 1 ? 'bg-turquoise-400 shadow-[0_0_8px_rgba(45,212,191,0.4)]' : 
                                      val === 2 ? 'bg-slateBlue-500 shadow-[0_0_8px_rgba(99,102,241,0.6)] border border-slateBlue-400' :
                                      val === 3 ? 'bg-deepPurple-600 shadow-[0_0_10px_rgba(126,34,206,0.8)] border border-deepPurple-500' :
                                      'hover:bg-white/10'}
                                `}></div>
                                {currentStep === stepIdx && (
                                    <div className="absolute inset-0 bg-white/20 z-20 pointer-events-none border-l border-white/40"></div>
                                )}
                            </div>
                        ))}
                    </div>
                </div>
            );
        }, (prev, next) => {
            return prev.trackData === next.trackData && prev.currentStep === next.currentStep;
        });

        function Dullah80sApp() {
            const [isReady, setIsReady] = useState(false); 
            const [showFx, setShowFx] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [showConfirm, setShowConfirm] = useState(false);
            const [collapsedPads, setCollapsedPads] = useState(false);
            const [drawMode, setDrawMode] = useState(false);

            // Audio Params
            const [bpm, setBpm] = useState(110);
            const [swing, setSwing] = useState(0); 
            const [volume, setVolume] = useState(0.8);
            const [drive, setDrive] = useState(0.0);
            const [reverbMix, setReverbMix] = useState(0.2);
            const [delayTime, setDelayTime] = useState(3);
            const [delayFeed, setDelayFeed] = useState(0.3);
            const [delayMix, setDelayMix] = useState(0.2);
            const [lpfFreq, setLpfFreq] = useState(20000); 
            const [hpfFreq, setHpfFreq] = useState(20);   

            // Seq
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [elapsedTime, setElapsedTime] = useState(0);
            
            // Data
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [patterns, setPatterns] = useState({
                A: Array(16).fill(null).map(() => Array(16).fill(0)),
                B: Array(16).fill(null).map(() => Array(16).fill(0)),
                C: Array(16).fill(null).map(() => Array(16).fill(0)),
                D: Array(16).fill(null).map(() => Array(16).fill(0))
            });
            const [activePattern, setActivePattern] = useState('A'); 
            const [playingPattern, setPlayingPattern] = useState('A'); 
            const [chainMode, setChainMode] = useState(false);
            const [clipboard, setClipboard] = useState(null);

            // Refs
            const audioCtxRef = useRef(null);
            const schedulerRef = useRef(null);
            const stepRef = useRef(0);
            const startTimeRef = useRef(0);
            const noiseBufferRef = useRef(null); 
            const masterBusRef = useRef(null);
            const hasStartedRef = useRef(false); 
            
            // Interaction Refs
            const isPaintingRef = useRef(false);
            const lastPaintCellRef = useRef(null);
            const paintTypeRef = useRef(null);
            const longPressTimerRef = useRef(null);
            const startPosRef = useRef({x:0, y:0});

            useEffect(() => {
                const saved = localStorage.getItem('dullah80s_v3_data');
                if (saved) { try { const data = JSON.parse(saved); setPatterns(data.patterns || patterns); setBpm(data.bpm || 110); setSwing(data.swing || 0); } catch (e) { } }
                if (history.length === 0) pushHistory(patterns);
            }, []);

            useEffect(() => {
                const timer = setTimeout(() => {
                    const data = { patterns, bpm, swing };
                    localStorage.setItem('dullah80s_v3_data', JSON.stringify(data));
                }, 1000);
                return () => clearTimeout(timer);
            }, [patterns, bpm, swing]);

            const pushHistory = (newPatterns) => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push(JSON.stringify(newPatterns));
                if(newHistory.length > 20) newHistory.shift();
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };
            const undo = () => { if (historyIndex > 0) { const newIndex = historyIndex - 1; setHistoryIndex(newIndex); setPatterns(JSON.parse(history[newIndex])); } };
            const redo = () => { if (historyIndex < history.length - 1) { const newIndex = historyIndex + 1; setHistoryIndex(newIndex); setPatterns(JSON.parse(history[newIndex])); } };

            const initAudio = () => {
                if (!audioCtxRef.current) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioContext();
                    audioCtxRef.current = ctx;
                    noiseBufferRef.current = generateNoiseBuffer(ctx);

                    const inputGain = ctx.createGain();
                    const driveNode = ctx.createWaveShaper(); driveNode.curve = generateDistortionCurve(0);
                    const hpf = ctx.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.value = hpfFreq;
                    const lpf = ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.frequency.value = lpfFreq;

                    const dryGain = ctx.createGain();
                    const delayNode = ctx.createDelay(5.0);
                    const delayFeedback = ctx.createGain(); delayFeedback.gain.value = delayFeed;
                    const delayWet = ctx.createGain(); delayWet.gain.value = delayMix;
                    delayNode.connect(delayFeedback).connect(delayNode);

                    const convolver = ctx.createConvolver();
                    try { convolver.buffer = generateImpulseResponse(ctx, 2.0, 2.0); } catch(e) {}
                    const reverbWet = ctx.createGain(); reverbWet.gain.value = reverbMix;

                    const masterVol = ctx.createGain(); masterVol.gain.value = volume;
                    const limiter = ctx.createDynamicsCompressor(); limiter.threshold.value = -1;

                    inputGain.connect(driveNode).connect(hpf).connect(lpf);
                    lpf.connect(dryGain); lpf.connect(delayNode); lpf.connect(convolver);
                    dryGain.connect(masterVol); delayNode.connect(delayWet).connect(masterVol); convolver.connect(reverbWet).connect(masterVol);
                    masterVol.connect(limiter).connect(ctx.destination);
                    
                    masterBusRef.current = { input: inputGain, drive: driveNode, hpf, lpf, delayNode, delayFeedback, delayWet, reverbWet, masterVol };
                }
                
                if (audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume().then(() => {
                        setIsReady(true);
                        hasStartedRef.current = true;
                    });
                } else {
                    setIsReady(true);
                    hasStartedRef.current = true;
                }
            };
            
            useEffect(() => {
                if (masterBusRef.current && audioCtxRef.current) {
                    const ctx = audioCtxRef.current;
                    const t = ctx.currentTime;
                    masterBusRef.current.drive.curve = generateDistortionCurve(drive * 100);
                    masterBusRef.current.masterVol.gain.setTargetAtTime(volume, t, 0.05);
                    masterBusRef.current.hpf.frequency.setTargetAtTime(hpfFreq, t, 0.1);
                    masterBusRef.current.lpf.frequency.setTargetAtTime(lpfFreq, t, 0.1);
                    masterBusRef.current.reverbWet.gain.setTargetAtTime(reverbMix, t, 0.1);
                    const stepTime = 60 / bpm / 4; 
                    masterBusRef.current.delayNode.delayTime.setTargetAtTime(Math.max(0.01, delayTime * stepTime), t, 0.1);
                    masterBusRef.current.delayFeedback.gain.setTargetAtTime(delayFeed, t, 0.1);
                    masterBusRef.current.delayWet.gain.setTargetAtTime(delayMix, t, 0.1);
                }
            }, [volume, drive, reverbMix, delayMix, delayTime, delayFeed, hpfFreq, lpfFreq, bpm]);

            const playSound = useCallback((index, time = null, type = 1) => {
                if (!audioCtxRef.current || !masterBusRef.current) return;
                const ctx = audioCtxRef.current;
                const t = time || ctx.currentTime;
                
                let vel = 0.8;
                let decayMult = 1.0;
                
                if (type === 2) { vel = 1.0; decayMult = 1.8; } // Long hold
                if (type === 3) { vel = 1.3; decayMult = 0.6; } // Punchy
                
                if (!time && navigator.vibrate) navigator.vibrate(type === 3 ? 30 : 10);
                
                const voiceOut = ctx.createGain(); 
                voiceOut.gain.value = vel; 
                voiceOut.connect(masterBusRef.current.input);

                const stop = (n) => { setTimeout(()=> { n.disconnect(); voiceOut.disconnect(); }, 1500); };

                switch (index) {
                    case 0: case 1: // Kick
                        const osc = ctx.createOscillator(); 
                        osc.frequency.setValueAtTime(index===0?55:75, t); 
                        osc.frequency.linearRampToValueAtTime(10, t + 0.4 * decayMult); 
                        const kg = ctx.createGain(); 
                        kg.gain.setValueAtTime(1.0, t); 
                        kg.gain.exponentialRampToValueAtTime(0.001, t + 0.4 * decayMult);
                        osc.connect(kg).connect(voiceOut); 
                        osc.start(t); osc.stop(t + 0.45 * decayMult); 
                        stop(osc); 
                        break;
                    case 2: case 3: // Snare
                        const sOsc = ctx.createOscillator(); sOsc.type = 'triangle'; sOsc.frequency.setValueAtTime(180, t);
                        const sG = ctx.createGain(); sG.gain.setValueAtTime(0.5, t); sG.gain.exponentialRampToValueAtTime(0.001, t + 0.2 * decayMult);
                        sOsc.connect(sG).connect(voiceOut); sOsc.start(t); sOsc.stop(t + 0.25 * decayMult); stop(sOsc);
                        if(noiseBufferRef.current) {
                            const n = ctx.createBufferSource(); n.buffer = noiseBufferRef.current;
                            const f = ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 3000;
                            const nG = ctx.createGain(); nG.gain.setValueAtTime(0.8, t); nG.gain.exponentialRampToValueAtTime(0.001, t + 0.25 * decayMult);
                            n.connect(f).connect(nG).connect(voiceOut); n.start(t); n.stop(t + 0.3 * decayMult); stop(n);
                        } break;
                    case 4: // Clap
                        if(noiseBufferRef.current) {
                            const n = ctx.createBufferSource(); n.buffer = noiseBufferRef.current;
                            const f = ctx.createBiquadFilter(); f.type = 'bandpass'; f.frequency.value = 1200;
                            const g = ctx.createGain(); g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(1, t + 0.01); g.gain.exponentialRampToValueAtTime(0.001, t + 0.2 * decayMult);
                            n.connect(f).connect(g).connect(voiceOut); n.start(t); n.stop(t + 0.25 * decayMult); stop(n);
                        } break;
                    case 5: // Rim
                        const rOsc = ctx.createOscillator(); rOsc.type = 'triangle'; rOsc.frequency.setValueAtTime(800, t);
                        const rG = ctx.createGain(); rG.gain.setValueAtTime(0.4, t); rG.gain.exponentialRampToValueAtTime(0.001, t + 0.05 * decayMult);
                        rOsc.connect(rG).connect(voiceOut); rOsc.start(t); rOsc.stop(t + 0.1 * decayMult); stop(rOsc); break;
                    case 6: case 7: // Hats (Open/Closed)
                        if(noiseBufferRef.current) {
                            const n = ctx.createBufferSource(); n.buffer = noiseBufferRef.current;
                            const f = ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 8000;
                            const g = ctx.createGain(); 
                            const baseDecay = index === 7 ? 0.4 : 0.05;
                            g.gain.setValueAtTime(0.6, t); g.gain.exponentialRampToValueAtTime(0.001, t + baseDecay * decayMult);
                            n.connect(f).connect(g).connect(voiceOut); n.start(t); n.stop(t + (baseDecay * decayMult) + 0.05); stop(n);
                        } break;
                    case 8: case 9: // Toms
                        const tOsc = ctx.createOscillator(); tOsc.frequency.setValueAtTime(index===8?200:100, t); tOsc.frequency.linearRampToValueAtTime(30, t + 0.3 * decayMult);
                        const tG = ctx.createGain(); tG.gain.setValueAtTime(0.6, t); tG.gain.exponentialRampToValueAtTime(0.001, t + 0.3 * decayMult);
                        tOsc.connect(tG).connect(voiceOut); tOsc.start(t); tOsc.stop(t + 0.35 * decayMult); stop(tOsc); break;
                    case 10: // Perc 1 (High Blip)
                        const pOsc = ctx.createOscillator(); pOsc.type = 'sine'; pOsc.frequency.setValueAtTime(800, t); pOsc.frequency.exponentialRampToValueAtTime(100, t + 0.1 * decayMult);
                        const pG = ctx.createGain(); pG.gain.setValueAtTime(0.5, t); pG.gain.exponentialRampToValueAtTime(0.001, t + 0.1 * decayMult);
                        pOsc.connect(pG).connect(voiceOut); pOsc.start(t); pOsc.stop(t + 0.15 * decayMult); stop(pOsc); break;
                    case 11: // Cowbell
                        const cOsc1 = ctx.createOscillator(); cOsc1.type = 'square'; cOsc1.frequency.value = 800;
                        const cOsc2 = ctx.createOscillator(); cOsc2.type = 'square'; cOsc2.frequency.value = 540;
                        const cF = ctx.createBiquadFilter(); cF.type = 'bandpass'; cF.frequency.value = 1000;
                        const cG = ctx.createGain(); cG.gain.setValueAtTime(0.4, t); cG.gain.exponentialRampToValueAtTime(0.001, t + 0.2 * decayMult);
                        cOsc1.connect(cF); cOsc2.connect(cF); cF.connect(cG).connect(voiceOut);
                        cOsc1.start(t); cOsc2.start(t); cOsc1.stop(t + 0.25); cOsc2.stop(t + 0.25); stop(cOsc1); break;
                    case 12: // Crash
                        if(noiseBufferRef.current) {
                            const n = ctx.createBufferSource(); n.buffer = noiseBufferRef.current;
                            const f = ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 2000;
                            const g = ctx.createGain(); g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.001, t + 1.5 * decayMult);
                            n.connect(f).connect(g).connect(voiceOut); n.start(t); n.stop(t + 1.6 * decayMult); stop(n);
                        } break;
                    case 13: // Laser
                        const lOsc = ctx.createOscillator(); lOsc.frequency.setValueAtTime(1200, t); lOsc.frequency.exponentialRampToValueAtTime(50, t + 0.15 * decayMult);
                        const lG = ctx.createGain(); lG.gain.setValueAtTime(0.5, t); lG.gain.exponentialRampToValueAtTime(0.001, t + 0.15 * decayMult);
                        lOsc.connect(lG).connect(voiceOut); lOsc.start(t); lOsc.stop(t + 0.2); stop(lOsc); break;
                    case 14: // Shaker
                         if(noiseBufferRef.current) {
                            const n = ctx.createBufferSource(); n.buffer = noiseBufferRef.current;
                            const f = ctx.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 5000;
                            const g = ctx.createGain(); g.gain.setValueAtTime(0.4, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05 * decayMult);
                            n.connect(f).connect(g).connect(voiceOut); n.start(t); n.stop(t + 0.1 * decayMult); stop(n);
                        } break;
                    case 15: // Vox (Formant-ish)
                        const vOsc = ctx.createOscillator(); vOsc.type = 'sawtooth'; vOsc.frequency.setValueAtTime(440, t); vOsc.frequency.linearRampToValueAtTime(300, t + 0.2);
                        const vF = ctx.createBiquadFilter(); vF.type = 'lowpass'; vF.frequency.setValueAtTime(800, t); vF.Q.value = 5;
                        const vG = ctx.createGain(); vG.gain.setValueAtTime(0.5, t); vG.gain.exponentialRampToValueAtTime(0.001, t + 0.3 * decayMult);
                        vOsc.connect(vF).connect(vG).connect(voiceOut); vOsc.start(t); vOsc.stop(t + 0.35); stop(vOsc); break;
                    default: break;
                }
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    if (!hasStartedRef.current) {
                        if (audioCtxRef.current?.state === 'suspended') audioCtxRef.current.resume();
                        hasStartedRef.current = true;
                    }
                    
                    startTimeRef.current = Date.now();
                    const stepTime = (60 * 1000) / bpm / 4; 
                    
                    schedulerRef.current = setInterval(() => {
                        const currentS = stepRef.current;
                        const now = audioCtxRef.current.currentTime;
                        const swingDelay = (currentS % 2 !== 0) ? (stepTime/1000) * swing : 0;
                        const playTime = now + 0.05 + swingDelay;
                        
                        const activeGrid = patterns[playingPattern];
                        for(let i=0; i<activeGrid.length; i++) { 
                            const cellState = activeGrid[i][currentS]; 
                            if(cellState > 0) playSound(i, playTime, cellState); 
                        }
                        
                        setCurrentStep(currentS);
                        setElapsedTime(Date.now() - startTimeRef.current);
                        
                        let nextStep = currentS + 1;
                        if (nextStep >= 16) {
                            nextStep = 0;
                            if (chainMode) {
                                const keys = PATTERN_KEYS;
                                const nextIdx = (keys.indexOf(playingPattern) + 1) % keys.length;
                                const nextPat = keys[nextIdx];
                                setPlayingPattern(nextPat);
                                setActivePattern(nextPat);
                            }
                        }
                        stepRef.current = nextStep;
                    }, stepTime);
                } else {
                    clearInterval(schedulerRef.current); stepRef.current = 0; setCurrentStep(0); setElapsedTime(0);
                }
                return () => clearInterval(schedulerRef.current);
            }, [isPlaying, bpm, patterns, chainMode, swing, playingPattern, playSound]);

            // --- 3-TIER INTERACTION LOGIC ---
            const getCell = (e) => {
                const x = e.touches ? e.touches[0].clientX : e.clientX;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                return document.elementFromPoint(x, y)?.closest('.grid-cell');
            };

            const updateCell = useCallback((trackIdx, stepIdx, newVal) => {
                 setPatterns(prev => {
                    const p = prev[activePattern];
                    if(p[trackIdx][stepIdx] === newVal) return prev;
                    const newTrack = [...p[trackIdx]]; newTrack[stepIdx] = newVal;
                    const newGrid = [...p]; newGrid[trackIdx] = newTrack;
                    return { ...prev, [activePattern]: newGrid };
                });
            }, [activePattern]);

            const handleStart = (e) => {
                if(e.button === 2) return; 
                const cell = getCell(e);
                if (!cell) return;
                
                const trackIdx = parseInt(cell.dataset.track);
                const stepIdx = parseInt(cell.dataset.step);
                
                startPosRef.current = { x: e.touches ? e.touches[0].clientX : e.clientX, y: e.touches ? e.touches[0].clientY : e.clientY };
                lastPaintCellRef.current = `${trackIdx}-${stepIdx}`;
                isPaintingRef.current = true; 
                
                const currentVal = patterns[activePattern][trackIdx][stepIdx];
                
                if (drawMode) {
                    paintTypeRef.current = currentVal === 0 ? 1 : 0;
                    if (!(paintTypeRef.current === 1 && (currentVal === 2 || currentVal === 3))) {
                        updateCell(trackIdx, stepIdx, paintTypeRef.current);
                    }
                } else {
                    let nextVal = 1;
                    if (currentVal === 1) nextVal = 2; 
                    else if (currentVal === 2) nextVal = 3; 
                    else if (currentVal === 3) nextVal = 1; 
                    
                    longPressTimerRef.current = setTimeout(() => {
                        if (navigator.vibrate) navigator.vibrate(50);
                        updateCell(trackIdx, stepIdx, nextVal);
                        isPaintingRef.current = false; 
                        lastPaintCellRef.current = null;
                    }, 350); 
                }

                if (!hasStartedRef.current && audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
                    audioCtxRef.current.resume();
                    hasStartedRef.current = true;
                }
            };

            const handleMove = (e) => {
                if (!isPaintingRef.current) return;
                
                const x = e.touches ? e.touches[0].clientX : e.clientX;
                const y = e.touches ? e.touches[0].clientY : e.clientY;
                const dist = Math.hypot(x - startPosRef.current.x, y - startPosRef.current.y);
                
                if (dist > 10) clearTimeout(longPressTimerRef.current); 

                if (drawMode) {
                    const cell = getCell(e);
                    if (!cell) return;
                    const trackIdx = parseInt(cell.dataset.track);
                    const stepIdx = parseInt(cell.dataset.step);
                    const cellKey = `${trackIdx}-${stepIdx}`;

                    if (cellKey !== lastPaintCellRef.current) {
                        lastPaintCellRef.current = cellKey;
                        const currentVal = patterns[activePattern][trackIdx][stepIdx];
                        if (!(paintTypeRef.current === 1 && (currentVal === 2 || currentVal === 3))) {
                            updateCell(trackIdx, stepIdx, paintTypeRef.current);
                        }
                    }
                }
            };

            const handleEnd = () => {
                clearTimeout(longPressTimerRef.current);
                if (isPaintingRef.current && !drawMode) {
                    const [tIdx, sIdx] = lastPaintCellRef.current.split('-').map(Number);
                    const currentVal = patterns[activePattern][tIdx][sIdx];
                    const newVal = currentVal === 0 ? 1 : 0;
                    updateCell(tIdx, sIdx, newVal);
                    pushHistory(patterns);
                }
                isPaintingRef.current = false;
                lastPaintCellRef.current = null;
            };

            const handleContextMenu = (e) => {
                e.preventDefault();
                const cell = getCell(e);
                if (!cell) return;
                const trackIdx = parseInt(cell.dataset.track);
                const stepIdx = parseInt(cell.dataset.step);
                setPatterns(prev => {
                    const p = prev[activePattern];
                    let newVal = 0;
                    const cur = p[trackIdx][stepIdx];
                    if(cur === 0 || cur === 1) newVal = 2;
                    else if(cur === 2) newVal = 3;
                    else newVal = 0;
                    
                    const newTrack = [...p[trackIdx]]; newTrack[stepIdx] = newVal;
                    const newGrid = [...p]; newGrid[trackIdx] = newTrack;
                    const next = { ...prev, [activePattern]: newGrid };
                    pushHistory(next); return next;
                });
            };

            const clearGrid = () => {
                const newP = { ...patterns, [activePattern]: Array(16).fill(null).map(() => Array(16).fill(0)) };
                setPatterns(newP);
                pushHistory(newP);
                setShowConfirm(false);
            };

            const formatTime = (ms) => {
                const totalSecs = Math.floor(ms / 1000);
                return `${Math.floor(totalSecs / 60)}:${(totalSecs % 60).toString().padStart(2, '0')}`;
            };

            const DiscoBallIcon = ({ size=24 }) => (
                <svg width={size} height={size} viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs><linearGradient id="prismGrad" x1="2" y1="2" x2="22" y2="22" gradientUnits="userSpaceOnUse"><stop offset="0%" stopColor="#2dd4bf"/><stop offset="40%" stopColor="#6366f1"/><stop offset="80%" stopColor="#a78bfa"/><stop offset="100%" stopColor="#2dd4bf"/></linearGradient></defs>
                    <circle cx="12" cy="12" r="10" fill="#1c1c1f" stroke="url(#prismGrad)" strokeWidth="1.5"/><path d="M12 2V22" stroke="rgba(255,255,255,0.15)" strokeWidth="0.5"/><path d="M2 12H22" stroke="rgba(255,255,255,0.15)" strokeWidth="0.5"/><circle cx="9" cy="9" r="1.5" fill="white" fillOpacity="0.8" filter="blur(1px)"/>
                </svg>
            );

            return (
                <div className="fixed inset-0 bg-charcoal-950 text-zinc-100 flex flex-col font-sans select-none overflow-hidden">
                    {!isReady && <div className="absolute inset-0 z-50 bg-charcoal-950/95 backdrop-blur-xl flex items-center justify-center flex-col gap-6 animate-in"><div className="relative w-24 h-24 flex items-center justify-center"><div className="absolute inset-0 bg-purple-500/60 rounded-full blur-3xl animate-glow-cycle"></div><DiscoBallIcon size={80} /></div><h1 className="text-3xl font-black tracking-tight text-white">DULLAH<span className="text-turquoise-400">80s</span></h1><button onClick={initAudio} className="px-8 py-3 bg-white text-charcoal-950 font-bold rounded-full shadow-[0_0_20px_rgba(255,255,255,0.3)]">TAP TO START</button></div>}
                    {showConfirm && <div className="absolute inset-0 z-[60] bg-black/60 backdrop-blur-sm flex items-center justify-center p-4 animate-in"><div className="bg-charcoal-900 border border-charcoal-700 p-6 rounded-2xl shadow-2xl max-w-xs w-full text-center"><h3 className="text-lg font-bold text-white mb-2 uppercase tracking-widest">Clear Pattern?</h3><p className="text-slate-400 text-sm mb-6">This cannot be undone easily.</p><div className="flex gap-3"><button onClick={()=>setShowConfirm(false)} className="flex-1 py-3 rounded-xl bg-charcoal-800 text-slate-300 font-bold">Cancel</button><button onClick={clearGrid} className="flex-1 py-3 rounded-xl bg-red-500/20 text-red-400 border border-red-500/50 font-bold">Clear</button></div></div></div>}

                    <nav className="h-14 bg-charcoal-900/80 backdrop-blur-md border-b border-charcoal-700/50 flex items-center justify-between px-4 shrink-0 pt-safe-top z-30">
                        <div className="flex items-center gap-3"><div className="w-9 h-9 bg-charcoal-800 rounded-lg border border-charcoal-700 flex items-center justify-center shadow-lg"><DiscoBallIcon size={22} /></div><h1 className="font-extrabold text-lg tracking-tight leading-none text-white">DULLAH<span className="text-turquoise-400">80s</span></h1></div>
                        <div className="flex items-center gap-3">
                            <div className="flex items-center gap-2 bg-charcoal-800/60 px-2 py-1 rounded-lg border border-charcoal-700/50"><span className="text-[8px] font-bold text-turquoise-400 uppercase">BPM</span><span className="font-mono text-xs font-bold">{bpm}</span><div className="flex flex-col -space-y-0.5"><button onClick={()=>setBpm(b=>Math.min(200, b+1))} className="p-1 text-slate-400 hover:text-turquoise-400"><Icon name="ChevronUp" size={10}/></button><button onClick={()=>setBpm(b=>Math.max(60, b-1))} className="p-1 text-slate-400 hover:text-turquoise-400"><Icon name="ChevronDown" size={10}/></button></div></div>
                            <div className="w-px h-6 bg-charcoal-700"></div>
                            <button onClick={() => setShowHelp(true)} className="w-9 h-9 flex items-center justify-center bg-charcoal-800/60 rounded-lg border border-charcoal-700/50 text-slate-400 hover:text-white"><Icon name="Help" size={18} /></button>
                            <button onClick={() => setShowFx(true)} className="w-9 h-9 flex items-center justify-center bg-charcoal-800/60 rounded-lg border border-charcoal-700/50 text-slate-400 hover:text-white"><Icon name="Settings" size={18} /></button>
                        </div>
                    </nav>

                    {showHelp && <div className="absolute inset-0 z-50 flex items-center justify-center p-4 animate-in"><div className="absolute inset-0 bg-black/40 backdrop-blur-sm" onClick={()=>setShowHelp(false)}></div><div className="w-full max-w-md liquid-glass rounded-2xl overflow-hidden relative z-10 flex flex-col max-h-[85vh] shadow-2xl"><div className="p-5 border-b border-white/10 flex justify-between items-center bg-white/5"><h2 className="font-bold text-base tracking-widest text-white uppercase">Instructions</h2><button onClick={()=>setShowHelp(false)}><Icon name="X" size={20}/></button></div><div className="p-6 space-y-4 text-sm text-slate-300 overflow-y-auto custom-scrollbar"><div className="space-y-2"><h3 className="text-turquoise-400 font-bold text-xs uppercase">1. Tap (Cyan)</h3><p>Standard Velocity.</p></div><div className="space-y-2"><h3 className="text-slateBlue-400 font-bold text-xs uppercase">2. Hold (Slate Blue)</h3><p>Longer Sustain/Hold.</p></div><div className="space-y-2"><h3 className="text-deepPurple-500 font-bold text-xs uppercase">3. Hold Again (Dark Purple)</h3><p>High Velocity, Punchy.</p></div></div></div></div>}

                    {showFx && <div className="absolute inset-0 z-50 flex items-center justify-center p-4 animate-in"><div className="absolute inset-0 bg-black/40 backdrop-blur-sm" onClick={()=>setShowFx(false)}></div><div className="w-full max-w-md liquid-glass rounded-2xl overflow-hidden relative z-10 flex flex-col max-h-[85vh] shadow-2xl"><div className="p-5 border-b border-white/10 flex justify-between items-center bg-white/5"><div className="flex items-center gap-2"><Icon name="Settings" size={18} className="text-turquoise-400"/><h2 className="font-bold text-base tracking-widest text-white uppercase">Studio Effects</h2></div><button onClick={()=>setShowFx(false)}><Icon name="Check" size={20} className="text-turquoise-400"/></button></div><div className="p-6 space-y-6 overflow-y-auto custom-scrollbar"><div className="bg-charcoal-900/50 p-3 rounded-xl border border-white/5"><div className="flex justify-between mb-2"><span className="text-xs font-bold text-slate-400 uppercase">Swing</span><span className="text-xs font-mono text-white">{Math.round(swing*100)}%</span></div><input type="range" min="0" max="0.5" step="0.05" value={swing} onChange={e=>setSwing(parseFloat(e.target.value))} className="w-full" /></div><div className="bg-charcoal-900/50 p-3 rounded-xl border border-white/5 space-y-4"><div className="flex items-center gap-2 mb-2"><span className="text-xs font-bold text-yellow-400 uppercase">Master EQ</span></div><div><div className="flex justify-between mb-1"><span className="text-[10px] text-slate-400">High Pass (Low Cut)</span><span className="text-[10px] text-slate-400">{hpfFreq} Hz</span></div><input type="range" min="20" max="500" step="10" value={hpfFreq} onChange={e=>setHpfFreq(parseFloat(e.target.value))} className="w-full" /></div><div><div className="flex justify-between mb-1"><span className="text-[10px] text-slate-400">Low Pass (High Cut)</span><span className="text-[10px] text-slate-400">{lpfFreq < 1000 ? lpfFreq : (lpfFreq/1000).toFixed(1)+'k'} Hz</span></div><input type="range" min="1000" max="20000" step="100" value={lpfFreq} onChange={e=>setLpfFreq(parseFloat(e.target.value))} className="w-full" /></div></div><div className="bg-charcoal-900/50 p-3 rounded-xl border border-white/5 space-y-3"><div className="flex items-center gap-2 mb-1"><span className="text-xs font-bold text-blue-400 uppercase">Echo / Delay</span></div><div className="grid grid-cols-2 gap-3"><div><span className="text-[10px] text-slate-400">Mix</span><input type="range" min="0" max="0.6" step="0.05" value={delayMix} onChange={e=>setDelayMix(parseFloat(e.target.value))} className="w-full"/></div><div><span className="text-[10px] text-slate-400">Fdbk</span><input type="range" min="0" max="0.8" step="0.05" value={delayFeed} onChange={e=>setDelayFeed(parseFloat(e.target.value))} className="w-full"/></div></div><div><div className="flex justify-between"><span className="text-[10px] text-slate-400">Time (Sync)</span><span className="text-[10px] text-slate-400">{delayTime}/16</span></div><input type="range" min="1" max="16" step="1" value={delayTime} onChange={e=>setDelayTime(parseFloat(e.target.value))} className="w-full"/></div></div><div className="bg-charcoal-900/50 p-3 rounded-xl border border-white/5"><div className="flex justify-between mb-2"><span className="text-xs font-bold text-purple-400 uppercase">Reverb</span></div><input type="range" min="0" max="0.8" step="0.05" value={reverbMix} onChange={e=>setReverbMix(parseFloat(e.target.value))} className="w-full" /></div><div className="bg-charcoal-900/50 p-3 rounded-xl border border-white/5"><div className="flex justify-between mb-2"><span className="text-xs font-bold text-slate-200 uppercase">Output Volume</span></div><input type="range" min="0" max="1" step="0.01" value={volume} onChange={e=>setVolume(parseFloat(e.target.value))} className="w-full" /></div></div></div></div>}

                    <div className="flex-1 flex flex-col relative z-0 min-h-0">
                        <div className={`bg-charcoal-900 border-b border-charcoal-800 transition-all duration-300 flex flex-col ${collapsedPads?'h-8':'h-[32vh] min-h-[180px]'}`}>
                            <button onClick={()=>setCollapsedPads(!collapsedPads)} className="h-8 w-full flex items-center justify-between px-4 bg-charcoal-800/50 hover:bg-charcoal-800 transition-colors"><span className="text-[9px] font-bold uppercase text-slate-500 tracking-widest">Live Pads</span><Icon name={collapsedPads?"ChevronDown":"ChevronUp"} size={14} className="text-slate-500"/></button>
                            <div className={`flex-1 p-2 ${collapsedPads?'hidden':'block'}`}><div className="grid grid-cols-4 gap-2 h-full">{PAD_NAMES.map((name, i) => (<button key={i} onPointerDown={(e)=>{e.target.releasePointerCapture(e.pointerId); playSound(i);}} className="bg-charcoal-800 border border-charcoal-700 rounded-lg relative group touch-manipulation select-none active:bg-white active:border-slateBlue-500 active:shadow-[0_0_20px_rgba(99,102,241,0.6)] transition-all duration-75"><span className="absolute bottom-1.5 left-2 text-[10px] font-bold text-slate-500 group-hover:text-slate-300 group-active:text-charcoal-950 transition-colors pointer-events-none">{name}</span><div className="absolute top-1.5 right-2 w-1.5 h-1.5 rounded-full bg-charcoal-900/50 group-active:bg-white/50"></div></button>))}</div></div>
                        </div>

                        <div className="h-14 bg-charcoal-950 border-b border-charcoal-800 flex items-center justify-between px-3 shrink-0 gap-2 overflow-hidden">
                            <div className="flex items-center gap-2 shrink-0 pr-2 border-r border-charcoal-800 h-full">
                                <button onClick={()=>{if(!isReady)initAudio(); setIsPlaying(!isPlaying);}} className={`flex items-center justify-center w-12 h-8 rounded-lg font-bold uppercase text-xs tracking-wider transition-all shadow-lg ${isPlaying ? 'bg-turquoise-500 text-charcoal-950 shadow-[0_0_10px_rgba(45,212,191,0.4)]' : 'bg-charcoal-800 text-slate-200 border border-charcoal-700'}`}><Icon name={isPlaying?"Square":"Play"} size={16} className={isPlaying?"fill-charcoal-950":""}/></button>
                                <button onClick={() => setDrawMode(!drawMode)} className={`flex items-center justify-center w-12 h-8 rounded-lg border text-xs font-bold transition-all ${drawMode ? 'bg-purple-500/20 text-purple-400 border-purple-500/50' : 'bg-charcoal-800 text-slate-400 border-charcoal-700 hover:text-white'}`}><Icon name="Pencil" size={16} /></button>
                            </div>
                            <div className="flex items-center gap-2 overflow-x-auto hide-scroll pl-1">
                                <div className="shrink-0 flex items-center gap-1 bg-charcoal-900 p-1 rounded-lg border border-charcoal-800"><button onClick={()=>setChainMode(!chainMode)} className={`h-7 w-7 flex items-center justify-center rounded transition-colors ${chainMode?'bg-turquoise-500/20 text-turquoise-400':'text-slate-600 hover:text-slate-400'}`}><Icon name="Repeat" size={14}/></button><div className="w-px h-4 bg-charcoal-700 mx-1"></div>{PATTERN_KEYS.map(k => (<button key={k} onClick={()=>{setActivePattern(k); if(!chainMode && !isPlaying) setPlayingPattern(k);}} className={`w-7 h-7 rounded text-[10px] font-bold border transition-all ${activePattern===k ? 'bg-charcoal-700 border-charcoal-600 text-white' : 'bg-transparent border-transparent text-slate-600 hover:text-slate-400'} ${playingPattern===k && isPlaying ? 'ring-1 ring-turquoise-400' : ''}`}>{k}</button>))}</div>
                                <div className="shrink-0 flex gap-1 bg-charcoal-900 p-1 rounded-lg border border-charcoal-800"><button onClick={undo} disabled={historyIndex<=0} className={`p-1.5 ${historyIndex<=0?'text-charcoal-700':'text-slate-500 hover:text-white'}`}><Icon name="Undo" size={16}/></button><button onClick={redo} disabled={historyIndex>=history.length-1} className={`p-1.5 ${historyIndex>=history.length-1?'text-charcoal-700':'text-slate-500 hover:text-white'}`}><Icon name="Redo" size={16}/></button><div className="w-px h-4 bg-charcoal-700 mx-1 self-center"></div><button onClick={()=>setClipboard(JSON.parse(JSON.stringify(patterns[activePattern])))} className="p-1.5 text-slate-500 hover:text-white"><Icon name="Copy" size={16}/></button><button onClick={()=>{if(clipboard){const p={...patterns,[activePattern]:JSON.parse(JSON.stringify(clipboard))};setPatterns(p);pushHistory(p);}}} className={`p-1.5 ${clipboard ? 'text-slate-200 hover:text-turquoise-400' : 'text-charcoal-700'}`} disabled={!clipboard}><Icon name="Paste" size={16}/></button><button onClick={()=>setShowConfirm(true)} className="p-1.5 text-red-900 hover:text-red-500"><Icon name="X" size={16}/></button></div>
                            </div>
                        </div>

                        <div 
                            className="flex-1 overflow-hidden bg-charcoal-950 relative flex flex-col min-h-0" 
                            style={{ touchAction: drawMode ? 'none' : 'auto' }}
                            onPointerDown={handleStart} 
                            onPointerMove={handleMove} 
                            onPointerUp={handleEnd} 
                            onContextMenu={handleContextMenu}
                        >
                            <div className="flex h-6 bg-charcoal-900 border-b border-charcoal-800 shrink-0 z-10 pointer-events-none">
                                <div className="w-20 shrink-0 border-r border-charcoal-800 bg-charcoal-900 flex flex-col items-center justify-center leading-none shadow-md relative z-20">
                                    <span className="text-[9px] font-bold text-turquoise-400 font-mono tracking-tighter">BAR {Math.floor(currentStep/4)+1}</span>
                                    <span className="text-[9px] text-slate-500 font-mono tracking-tighter">{formatTime(elapsedTime)}</span>
                                </div>
                                <div className="flex-1 flex">
                                    {Array(16).fill(0).map((_,i)=>(<div key={i} className={`flex-1 border-r border-charcoal-800/50 text-[8px] flex items-center justify-center font-mono ${i%4===0?'text-turquoise-400 font-bold bg-turquoise-900/10':'text-charcoal-600'}`}>{i+1}</div>))}
                                </div>
                            </div>
                            <div className="flex-1 overflow-y-auto pb-20 custom-scrollbar">
                                {PAD_NAMES.map((name, trackIdx) => ( <GridRow key={trackIdx} trackIdx={trackIdx} name={name} trackData={patterns[activePattern][trackIdx]} currentStep={currentStep} /> ))}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Dullah80sApp />);
    </script>
</body>
</html>

